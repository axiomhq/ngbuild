package core

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os/exec"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// MockIntegration is an autogenerated mock type for the MockIntegration type
type MockIntegration struct {
	mock.Mock
}

// AttachToApp provides a mock function with given fields: _a0
func (_m *MockIntegration) AttachToApp(_a0 App) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(App) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Identifier provides a mock function with given fields:
func (_m *MockIntegration) Identifier() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// IsProvider provides a mock function with given fields: _a0
func (_m *MockIntegration) IsProvider(_a0 string) bool {
	ret := _m.Called(_a0)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ProvideFor provides a mock function with given fields: c, directory
func (_m *MockIntegration) ProvideFor(c *BuildConfig, directory string) error {
	ret := _m.Called(c, directory)

	var r0 error
	if rf, ok := ret.Get(0).(func(*BuildConfig, string) error); ok {
		r0 = rf(c, directory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Shutdown provides a mock function with given fields:
func (_m *MockIntegration) Shutdown() {
	_m.Called()
}

// mockApp is an autogenerated mock type for the mockApp type
type mockApp struct {
	mock.Mock
}

// AppLocation provides a mock function with given fields:
func (_m *mockApp) AppLocation() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Config provides a mock function with given fields: namespace, conf
func (_m *mockApp) Config(namespace string, conf interface{}) error {
	ret := _m.Called(namespace, conf)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(namespace, conf)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBuild provides a mock function with given fields: token
func (_m *mockApp) GetBuild(token string) (Build, error) {
	ret := _m.Called(token)

	var r0 Build
	if rf, ok := ret.Get(0).(func(string) Build); ok {
		r0 = rf(token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBuildHistory provides a mock function with given fields: group
func (_m *mockApp) GetBuildHistory(group string) []Build {
	ret := _m.Called(group)

	var r0 []Build
	if rf, ok := ret.Get(0).(func(string) []Build); ok {
		r0 = rf(group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Build)
		}
	}

	return r0
}

// GlobalConfig provides a mock function with given fields: conf
func (_m *mockApp) GlobalConfig(conf interface{}) error {
	ret := _m.Called(conf)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(conf)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Listen provides a mock function with given fields: event, listener
func (_m *mockApp) Listen(event string, listener func(map[string]string)) EventHandler {
	ret := _m.Called(event, listener)

	var r0 EventHandler
	if rf, ok := ret.Get(0).(func(string, func(map[string]string)) EventHandler); ok {
		r0 = rf(event, listener)
	} else {
		r0 = ret.Get(0).(EventHandler)
	}

	return r0
}

// Logcritf provides a mock function with given fields: _a0, _a1
func (_m *mockApp) Logcritf(_a0 string, _a1 ...interface{}) {
	_m.Called(_a0, _a1)
}

// Loginfof provides a mock function with given fields: _a0, _a1
func (_m *mockApp) Loginfof(_a0 string, _a1 ...interface{}) {
	_m.Called(_a0, _a1)
}

// Logwarnf provides a mock function with given fields: _a0, _a1
func (_m *mockApp) Logwarnf(_a0 string, _a1 ...interface{}) {
	_m.Called(_a0, _a1)
}

// Name provides a mock function with given fields:
func (_m *mockApp) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// NewBuild provides a mock function with given fields: group, config
func (_m *mockApp) NewBuild(group string, config *BuildConfig) (string, error) {
	ret := _m.Called(group, config)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, *BuildConfig) string); ok {
		r0 = rf(group, config)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *BuildConfig) error); ok {
		r1 = rf(group, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveEventHandler provides a mock function with given fields: _a0
func (_m *mockApp) RemoveEventHandler(_a0 EventHandler) {
	_m.Called(_a0)
}

// SendEvent provides a mock function with given fields: event
func (_m *mockApp) SendEvent(event string) {
	_m.Called(event)
}

// Shutdown provides a mock function with given fields:
func (_m *mockApp) Shutdown() {
	_m.Called()
}

func getSuccessfulIntegration() *MockIntegration {
	i := &MockIntegration{}
	i.On("Identifier").Return("Success")
	i.On("IsProvider", mock.Anything).Return(true)
	i.On("ProvideFor", mock.AnythingOfType("*core.BuildConfig"), mock.AnythingOfType("string")).Run(func(args mock.Arguments) {
		dir := args.Get(1).(string)
		//FIXME - this is lazy, stops tests running on windows, is bad in general, i'm so tired
		cmd := exec.Command("cp", "testdata/failure.sh", "testdata/success.sh", "testdata/fiveminutes.sh", dir)
		cmd.Run() //nolint (errcheck)
	}).Return(nil)
	return i
}

func getFailedIntegration() *MockIntegration {
	i := &MockIntegration{}
	i.On("Identifier").Return("Success")
	i.On("IsProvider", mock.Anything).Return(true)
	i.On("ProvideFor", mock.Anything, mock.Anything).Return(errors.New("testmarker"))
	return i
}

func getMockApp() App {
	app := &mockApp{}
	app.On("SendEvent", mock.AnythingOfType("string")).Return()
	app.On("Name").Return("MockApp")
	app.On("Logcritf", mock.AnythingOfType("string"), mock.AnythingOfType("[]interface {}")).Run(func(args mock.Arguments) {
		str := args.Get(0).(string)
		fmts := args.Get(1).([]interface{})
		fmt.Printf(str+"\n", fmts...)
	}).Return()
	app.On("Logwarnf", mock.AnythingOfType("string"), mock.AnythingOfType("[]interface {}")).Run(func(args mock.Arguments) {
		str := args.Get(0).(string)
		fmts := args.Get(1).([]interface{})
		fmt.Printf(str+"\n", fmts...)
	}).Return()
	app.On("Loginfof", mock.AnythingOfType("string"), mock.AnythingOfType("[]interface {}")).Run(func(args mock.Arguments) {
		str := args.Get(0).(string)
		fmts := args.Get(1).([]interface{})
		fmt.Printf(str+"\n", fmts...)
	}).Return()
	app.On("GlobalConfig", mock.Anything).Return(nil)

	return app
}

func TestProvisionBuildIntoDirectory(t *testing.T) {
	assert := assert.New(t)
	require := require.New(t)
	app := getMockApp()
	b := build{token: "testtoken", parentApp: app}
	dir, err := provisionDirectory("")
	require.NoError(err)

	integrationSuccess := getSuccessfulIntegration()
	integrationFailure := getFailedIntegration()

	config := BuildConfig{
		BaseRepo:     "testmarker-baserepo",
		HeadRepo:     "testmarker-mergerepo",
		Integrations: []Integration{integrationFailure, integrationSuccess},
	}

	assert.NoError(b.provisionBuildIntoDirectory(&config, dir))
	assert.NoError(cleanupDirectory(dir))
}

func TestRunBuildSync(t *testing.T) {
	require := require.New(t)
	assert := assert.New(t)

	app := getMockApp()
	b := build{token: "testtoken", parentApp: app}
	b.config = &BuildConfig{
		Integrations: []Integration{getSuccessfulIntegration()},
		BuildRunner:  "success.sh",
		Deadline:     time.Second * 5,
	}
	b.Ref()

	require.NoError(b.runBuildSync(*b.config))

	stdoutpipe, err := b.Stdout()
	require.NoError(err)
	stdout, err := ioutil.ReadAll(stdoutpipe)
	require.NoError(err)
	assert.EqualValues([]byte("testmarker\n"), stdout)

	stderrpipe, err := b.Stderr()
	require.NoError(err)
	stderr, err := ioutil.ReadAll(stderrpipe)
	require.NoError(err)
	assert.EqualValues([]byte("testmarker\n"), stderr)
	b.Unref()
	assert.Empty(b.buildDirectory)

	require.True(b.state.HasStopped())
}

func TestRunBuildSyncFailure(t *testing.T) {
	require := require.New(t)
	assert := assert.New(t)

	app := getMockApp()
	b := build{token: "testtoken", parentApp: app}
	b.config = &BuildConfig{
		Integrations: []Integration{getSuccessfulIntegration()},
		BuildRunner:  "failure.sh",
		Deadline:     time.Second * 5,
	}
	b.Ref()

	require.Error(b.runBuildSync(*b.config))

	stdoutpipe, err := b.Stdout()
	require.NoError(err)
	stdout, err := ioutil.ReadAll(stdoutpipe)
	require.NoError(err)
	assert.EqualValues([]byte("testmarker\n"), stdout)

	stderrpipe, err := b.Stderr()
	require.NoError(err)
	stderr, err := ioutil.ReadAll(stderrpipe)
	require.NoError(err)
	assert.EqualValues([]byte("testmarker\n"), stderr)
	b.Unref()
	assert.Empty(b.buildDirectory)
	require.True(b.state.HasStopped())
}

func TestRunBuildSyncDeadline(t *testing.T) {
	require := require.New(t)
	assert := assert.New(t)
	app := getMockApp()
	b := build{token: "testtoken", parentApp: app}
	b.config = &BuildConfig{
		Integrations: []Integration{getSuccessfulIntegration()},
		BuildRunner:  "fiveminutes.sh",
		Deadline:     time.Second,
	}
	b.Ref()

	require.Error(b.runBuildSync(*b.config))

	stdoutpipe, err := b.Stdout()
	require.NoError(err)
	stdout, err := ioutil.ReadAll(stdoutpipe)
	require.NoError(err)
	assert.EqualValues([]byte("testmarker\n"), stdout)
	b.Unref()
	assert.Empty(b.buildDirectory)
	require.True(b.state.HasStopped())
}
